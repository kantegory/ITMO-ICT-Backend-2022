{"version":3,"file":"index.js","sources":["../src/sql.ts","../src/connection.ts"],"sourcesContent":["type PrimitiveValue = string | number | Buffer | bigint | boolean | null | Date;\ntype SingleValue = PrimitiveValue | SqlFrag\ntype Value = SingleValue | SingleValue[];\ntype OptionalValue = Value|undefined\n\ntype StrictDatabaseId = [database: string]\ntype LooseDatabaseId = StrictDatabaseId | string\n\ntype StrictTableId = [database: string, table: string] | [table: string]\ntype LooseTableId = StrictTableId | string\ntype TableId = LooseTableId | SqlFrag\n\ntype StrictColumnId = [column: string] | [table: string, column: string] | [database: string, table: string, column: string]\ntype LooseColumnId = StrictColumnId | string;\ntype ColumnId = LooseColumnId | SqlFrag\n\ntype LooseId = LooseColumnId;\ntype Id = LooseId | SqlFrag;\n\ntype LatLngPair = [lat: number, lng: number]\ntype PointArray = LatLngPair[] | Point[] | LatLngObj[]\n\ninterface Point {\n    x: number\n    y: number\n}\n\ninterface LatLngObj {\n    lat: number\n    lng: number\n}\n\nconst CHARS_REGEX = /[\\x00\\b\\n\\r\\t\\x1A'\\\\]/gu;\nconst CHARS_ESCAPE_MAP: Record<string,string> = {\n    '\\0': '\\\\0',\n    '\\b': '\\\\b',\n    '\\n': '\\\\n',\n    '\\r': '\\\\r',\n    '\\t': '\\\\t',\n    '\\x1a': '\\\\Z',\n    '\\'': \"''\",\n    '\\\\': '\\\\\\\\'\n};\nconst ID_GLOBAL_REGEXP = /`/g;\nconst QUAL_GLOBAL_REGEXP = /\\./g;\n\nexport class SqlFrag {\n    constructor(private readonly sql: string) {\n    }\n\n    toString() {\n        throw new Error(\"SqlFrag cannot be cast to string\");\n    }\n\n    toSqlString() {\n        return this.sql;\n    }\n}\n\nexport function isFrag(x: any): x is SqlFrag {\n    return x instanceof SqlFrag;\n}\n\nfunction frag(sql: string): SqlFrag {\n    return new SqlFrag(sql)\n}\n\nexport function escapeValue(value: Value): SqlFrag {\n    if (isFrag(value)) return value;\n    return frag(_escapeValue(value));\n}\n\nexport function sql(strings: TemplateStringsArray, ...values: Value[]): SqlFrag {\n    let out = [];\n    let i = 0;\n    for (; i < values.length; ++i) {\n        out.push(strings[i], escapeValue(values[i]).toSqlString());\n    }\n    out.push(strings[i]);\n    return frag(out.join(''));\n}\n\nexport function _escapeValue(value: Value): string {\n    if (isFrag(value)) {\n        return value.toSqlString();\n    }\n    if(Array.isArray(value)) {\n        if(!value.length) return '/*emptyArr*/NULL'\n        return value.map(v => _escapeValue(v)).join(',');\n    }\n    if(Buffer.isBuffer(value)) {\n        return `x'${value.toString('hex')}'`;\n    }\n    if(typeof value === 'number' || typeof value === 'bigint') {\n        return String(value);\n    }\n    if(typeof value === 'string') {\n        return _escapeString(value);\n    }\n    if(value === true) {\n        return '1';\n    }\n    if(value === false) {\n        return '0';\n    }\n    if(value === null) {\n        return 'NULL';\n    }\n    if(value instanceof Date) {\n        return `TIMESTAMP'${value.toISOString().replace('T', ' ').replace(/(?:\\.000)?Z$/, '')}'`\n    }\n    throw new Error(`Unsupported value type: ${value}`)\n}\n\nfunction hasOwn(obj: object, key: PropertyKey) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\n\nfunction _escapeString(value: string): string {\n    return \"'\" + String(value).replace(CHARS_REGEX,m => CHARS_ESCAPE_MAP[m]) + \"'\";\n}\n\nfunction escapeIdStrictFrag(id: Id): SqlFrag {\n    if (isFrag(id)) return id;\n    if (Array.isArray(id)) return frag(id.map(_escapeIdStrict).join('.'));\n    return frag(_escapeIdStrict(id));\n}\n\n\nexport function _escapeIdLoose(id: Id): string {\n    if(isFrag(id)) return id.toSqlString();\n    if(Array.isArray(id)) return id.map(_escapeIdStrict).join('.');\n    return '`' + String(id).replace(ID_GLOBAL_REGEXP, '``').replace(QUAL_GLOBAL_REGEXP, '`.`') + '`';\n}\n\nexport function _escapeIdStrict(id: Id): string {\n    if(isFrag(id)) return id.toSqlString();\n    if(Array.isArray(id)) return id.map(_escapeIdStrict).join('.');\n    return '`' + String(id).replace(ID_GLOBAL_REGEXP, '``') + '`';\n}\n\nfunction pointPairs(points: PointArray): LatLngPair[] {\n    if (!points.length) return [];\n    const sample = points[0];\n    if (Array.isArray(sample) && sample.length === 2) {\n        return [...points] as LatLngPair[];\n    }\n    if (hasOwn(sample, 'x') && hasOwn(sample, 'y')) {\n        return (points as Point[]).map(pt => [pt.x, pt.y]);\n    }\n    if (hasOwn(sample, 'lat') && hasOwn(sample, 'lng')) {\n        return (points as LatLngObj[]).map(pt => [pt.lat, pt.lng]);\n    }\n    throw new Error(\"Points are not in an expected format\")\n}\n\nexport interface InsertOptions {\n    /**\n     * What to do if a duplicate key is found.\n     */\n    onDuplicateKey?: DuplicateKey\n    /**\n     * Ignore all errors.\n     */\n    ignore?: boolean\n}\n\nconst EMPTY_OBJECT: Record<string,any> = Object.freeze({__proto__:null})\n\nexport enum DuplicateKey {\n    /** Don't insert duplicate records. */\n    IGNORE = 'ignore',\n    /** Update record with new values. */\n    UPDATE = 'update',\n}\n\n// https://stackoverflow.com/questions/65976300/how-to-properly-extend-a-record\ntype Columns<T> = keyof T & string\ntype TableSchema<T> = Record<Columns<T>, Value>\n// type TableSchema<T> = {[P in keyof T]?: Value}\ntype AnySchema = Record<string, Value>\ntype ColumnValueTuple<T> = [column: Columns<T>|ColumnId, value: Value]\ntype InsertData<T extends TableSchema<T>> =  T|ColumnValueTuple<T>[]\n\n\nfunction getFields<T extends TableSchema<T>>(o: T) {\n    return Object.keys(o).filter(k => (o as any)[k] !== undefined) as Array<keyof T & string>\n}\n\n\n// interface ObjectConstructor {\n//     keys<T extends object>(o: T): Array<keyof T & string>\n// }\n\nconst TRUE_SQL = sql`1`\nconst FALSE_SQL = sql`0`\n\nexport namespace sql {\n    export function set<T extends TableSchema<T>>(fields: InsertData<T>): SqlFrag {\n        if(Array.isArray(fields)) {\n            const filteredFields = fields.filter(p => p[1] !== undefined)\n            if(!filteredFields.length) throw new Error(\"No fields defined\")\n            return frag(\n                filteredFields\n                    .map(f => `${_escapeIdStrict(f[0])}=${_escapeValue(f[1] as Value)}`)\n                    .join(', ')\n            );\n        }\n        const filteredFields = getFields(fields)\n        if(!filteredFields.length) throw new Error(\"No fields defined\")\n        return frag(\n            filteredFields\n                .map(fieldName => `${_escapeIdLoose(fieldName)}=${_escapeValue((fields as AnySchema)[fieldName])}`)\n                .join(', ')\n        );\n    }\n    export function insert<T extends TableSchema<T>>(table: TableId, data: InsertData<T>, options: InsertOptions=EMPTY_OBJECT): SqlFrag {\n        let q = sql`INSERT ${frag(options.ignore ? 'IGNORE ' : '')}INTO ${escapeIdStrictFrag(table)} SET ${sql.set(data)}`;\n\n        if (options.onDuplicateKey === DuplicateKey.IGNORE) {\n            let firstCol: Id;\n            if (Array.isArray(data)) {\n                firstCol = data[0][0]\n            } else {\n                firstCol = Object.keys(data)[0];\n            }\n            const escCol = frag(_escapeIdLoose(firstCol));\n            q = sql`${q} ON DUPLICATE KEY UPDATE ${escCol}=${escCol}`;\n        } else if(options.onDuplicateKey === DuplicateKey.UPDATE) {\n            let cols: Id[];\n            if(Array.isArray(data)) {\n                cols = data.map(f => f[0] as ColumnId);\n            } else {\n                cols = getFields(data);\n            }\n            q = sql`${q} ON DUPLICATE KEY UPDATE ${cols.map(col =>{\n                const escCol = frag(_escapeIdLoose(col));\n                return sql`${escCol}=VALUES(${escCol})`\n            })}`;\n        }\n        return q;\n    }\n    // TODO: bulkInsert\n    // TODO: update?\n\n    export function alias(fields: Record<string, ColumnId>|Array<[column:ColumnId,alias:string]>): SqlFrag {\n        if(Array.isArray(fields)) {\n            return frag(fields.map(f => `${_escapeIdStrict(f[0])} AS ${_escapeIdStrict(f[1])}`).join(', '));\n        }\n        return frag(getFields(fields).map(alias => `${_escapeIdStrict(fields[alias])} AS ${_escapeIdStrict(alias)}`).join(', '));\n    }\n    export function raw(sqlString: string | SqlFrag): SqlFrag {\n        if (isFrag(sqlString)) return sqlString;\n        return frag(sqlString);\n    }\n    // export function timestamp(value: moment.MomentInput, outputTimezone?: string | null, inputTimezone?: string | null, fsp?: number | null): SqlFrag {\n    //     // https://dev.mysql.com/doc/refman/5.7/en/date-and-time-literals.html\n    //     // https://momentjs.com/docs/#/displaying/format/\n    //     const date = makeMoment(value, outputTimezone, inputTimezone);\n    //     let frac = '';\n    //     if (fsp != null) {\n    //         if (fsp < 0 || fsp > 6) {\n    //             // https://dev.mysql.com/doc/refman/8.0/en/date-and-time-type-overview.html\n    //             throw new Error(`fsp out of range: ${fsp}`);\n    //         } else if (fsp > 0) {\n    //             frac = '.' + 'S'.repeat(fsp);\n    //         }\n    //     } else if (date.milliseconds() !== 0) {\n    //         frac = '.SSS';\n    //     }\n    //\n    //     return raw(`TIMESTAMP'${date.format(`YYYY-MM-DD HH:mm:ss${frac}`)}'`)\n    // }\n    export function point(x: number, y: number): SqlFrag  {\n        return sql`PointFromText(${`POINT(${x} ${y})`})`;\n    }\n    // export function polygon(points: PointArray, autoComplete = true): SqlFrag  {\n    //     // https://dev.mysql.com/doc/refman/5.7/en/gis-data-formats.html\n    //     // https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Well-known_binary\n    //     if (!points.length) throw new Error(\"Cannot create an empty polygon\");\n    //     points = pointPairs(points);\n    //     if (autoComplete) {\n    //         const l = points.length - 1;\n    //         if (!(points[0][0] === points[l][0] && points[0][1] === points[l][1])) {\n    //             points.push([points[0][0], points[0][1]]);\n    //         }\n    //     }\n    //     return sql`PolyFromText(${`POLYGON((${\n    //         points.map(([x, y]) => `${x} ${y}`).join(',')\n    //     }))`})`;\n    // }\n    export function id(id: Id): SqlFrag {\n        return escapeIdStrictFrag(id)\n    }\n    /** @deprecated */\n    export function db(id: LooseDatabaseId): SqlFrag {\n        return escapeIdStrictFrag(id)\n    }\n    /** @deprecated */\n    export function tbl(id: LooseTableId): SqlFrag {\n        return escapeIdStrictFrag(id)\n    }\n    /** @deprecated */\n    export function col(id: LooseColumnId): SqlFrag {\n        return escapeIdStrictFrag(id)\n    }\n    export function cols(...columns: Array<ColumnId>): SqlFrag {\n        // TODO: make this even stricter? use max array len of 3\n        return frag(columns.map(_escapeIdStrict).join(', '))\n    }\n    /** @deprecated */\n    export function columns(columns: Array<ColumnId>): SqlFrag {\n        return frag(columns.map(_escapeIdStrict).join(', '))\n    }\n    export function values(values: Value[][]): SqlFrag {\n        return frag(values.map(row => `(${row.map(_escapeValue).join(',')})`).join(',\\n'))\n    }\n}\n","import MariaDB, {FieldInfo} from 'mariadb'\nimport {sql, SqlFrag} from './sql'\n// import stream from 'stream'\n// type AsyncFunction = (...args: any[]) => Promise<any>\n\n\nexport class ConnectionPool {\n\n    constructor(private readonly pool: MariaDB.Pool) {\n    }\n\n    async getConnection() {\n        return new PoolConnection(await this.pool.getConnection())\n    }\n\n    private _fwd<K extends keyof typeof PoolConnection.prototype>(method: K): typeof PoolConnection.prototype[K] {\n        return (async (...args: any[]) => {\n            const conn = await this.getConnection()\n            try {\n                return await (conn[method] as any)(...args)\n            } finally {\n                conn.release()  // TODO: what if release fails? should we at least log something?\n            }\n        }) as any\n    }\n\n    query = this._fwd('query')\n    exec = this._fwd('exec')\n    row = this._fwd('row')\n    col = this._fwd('col')\n    value = this._fwd('value')\n    exists = this._fwd('exists')\n    count = this._fwd('count')\n\n    async* stream<TRecord extends object = DefaultRecordType>(query: SqlFrag): AsyncGenerator<TRecord, unknown, undefined> {\n        const conn = await this.getConnection()\n        try {\n            yield* conn.stream(query)\n        } finally {\n            conn.release()\n        }\n        return\n    }\n\n    // close = this.pool.end.bind(this.pool)\n    close() {\n        return this.pool.end()\n    }\n\n    async transaction<TReturn>(callback: (conn: PoolConnection) => Promise<TReturn>): Promise<TReturn>;\n    async transaction<TUnionResults=DefaultRecordType>(callback: SqlFrag[]): Promise<QueryResult<TUnionResults>[]>;\n    async transaction<TResult>(callback: any): Promise<any> {\n        if (Array.isArray(callback)) {\n            return this.transaction<any>(async conn => {\n                const results = await Promise.allSettled(callback.map(sql => conn.query(sql)))\n                if (results.some(r => r.status === 'rejected')) {\n                    const errors = zip(callback, results).map((x, i) => ({\n                        index: i,\n                        query: x[0],\n                        result: x[1],\n                    })).filter(r => r.result.status === 'rejected')\n                    throw Error(`${errors.length} quer${errors.length === 1 ? 'y' : 'ies'} failed:${errors.map(err => `\\n[${err.index}] ${err.query.toSqlString()} :: ${(err.result as any).reason}`).join('')}`)\n                }\n                return results.map(r => (r as any).value)\n            })\n        }\n\n        const conn = await this.getConnection()\n        try {\n            await conn.beginTransaction()\n            let result: TResult\n            try {\n                result = await callback(conn)\n            } catch (err) {\n                await conn.rollback()\n                throw err\n            }\n            await conn.commit()\n            return result\n        } finally {\n            await conn.release()\n        }\n    }\n\n\n    get activeConnections() {\n        return this.pool.activeConnections()\n    }\n\n    get totalConnections() {\n        return this.pool.totalConnections()\n    }\n\n    get idleConnections() {\n        return this.pool.idleConnections()\n    }\n\n    get taskQueueSize() {\n        return this.pool.taskQueueSize()\n    }\n}\n\nfunction zip<A, B>(a: A[], b: B[]): Array<[A, B]> {\n    if (a.length !== b.length) throw new Error(\"Cannot zip arrays; lengths differ\")\n    return a.map((x, i) => [x, b[i]])\n}\n\ninterface QueryOptions extends MariaDB.QueryConfig {\n    sql: SqlFrag\n}\n\ntype QueryParam = SqlFrag | QueryOptions\n\nfunction makeOptions(query: QueryParam) {\n    if (query instanceof SqlFrag) {\n        return {sql: query}\n    } else if (typeof query === 'object') {\n        return query\n    }\n    throw new Error(`Expected sql\\`template string\\` or {options}, got ${typeof query}`)\n}\n\nexport const META = 'meta'\nexport type DefaultValueType = string | number | Buffer | boolean | Date | bigint | null\nexport type DefaultRecordType = Record<string, DefaultValueType>\nexport type QueryResult<T = DefaultRecordType> = T[] & { [META]: FieldInfo[] }\n\nclass PoolConnection {\n\n    constructor(private readonly conn: MariaDB.PoolConnection) {\n    }\n\n    query<TRecord = DefaultRecordType>(query: QueryParam): Promise<QueryResult<TRecord>> {\n        const opts = makeOptions(query)\n        return this.conn.query({\n            ...opts,\n            sql: opts.sql.toSqlString(),\n        })\n    }\n\n    exec: ((...args: Parameters<typeof PoolConnection.prototype.query>) => Promise<MariaDB.UpsertResult>) = this.query.bind(this) as any\n\n    async row<TRecord extends object = DefaultRecordType>(query: QueryParam): Promise<TRecord | null> {\n        const opts = makeOptions(query)\n        const rows = await this.query<TRecord>({\n            ...opts,\n            sql: sql`select * from (${opts.sql}) _query limit 1`\n        })\n        return rows.length ? rows[0] : null\n    }\n\n    async col<TValue=DefaultValueType>(query: SqlFrag): Promise<TValue[]> {\n        const rows = await this.query<any[]>({\n            sql: query,\n            rowsAsArray: true,\n        })\n        if(!rows.length) return []\n        if (rows[0].length !== 1) throw new Error(`Expected exactly 1 field in query, got ${rows[0].length}`)\n        return rows.map(r => r[0])\n    }\n\n    async value<TValue = DefaultValueType>(query: SqlFrag): Promise<TValue | null> {\n        const row = await this.row<TValue[]>({\n            sql: query,\n            rowsAsArray: true,\n        })\n        if (!row) return null\n        if (row.length !== 1) throw new Error(`Expected exactly 1 field in query, got ${row.length}`)\n        return row[0]\n    }\n\n    async exists(query: SqlFrag): Promise<boolean> {\n        return Boolean(await this.value<0 | 1>(sql`select exists(${query})`))\n    }\n\n    async count(query: SqlFrag) {\n        return Number(await this.value(sql`select count(*) from (${query}) _query`))\n    }\n\n    async* stream<TRecord extends object = DefaultRecordType>(query: SqlFrag): AsyncGenerator<TRecord, unknown, undefined> {\n        let results: TRecord[] = [];\n        let resolve: () => void;\n        let promise = new Promise<void>(r => resolve = r);\n        let done = false;\n\n        this.conn.queryStream(query.toSqlString())\n            .on('error', err => {\n                throw err;\n            })\n            .on('data', row => {\n                results.push(row);\n                resolve();\n            })\n            .on('end', () => {\n                done = true;\n                resolve();\n            })\n\n        for(;;) {\n            await promise;\n            yield* results;\n            if(done) break\n            promise = new Promise(r => resolve = r);\n            results = [];\n        }\n        return\n    }\n\n    release() { return this.conn.release() }\n    beginTransaction() { return this.conn.beginTransaction() }\n    commit() { return this.conn.commit() }\n    rollback() { return this.conn.rollback() }\n    ping() { return this.conn.ping() }\n    changeUser() { return this.conn.changeUser() }\n    close() { return this.conn.end() }\n    destroy() { return this.conn.destroy() }\n\n    get serverVersion() {\n        return this.conn.serverVersion()\n    }\n\n    get isValid() {\n        return this.conn.isValid()\n    }\n}\n\nexport async function createPool(config: MariaDB.PoolConfig) {\n    return new ConnectionPool(await MariaDB.createPool({\n        supportBigInt: true,\n        dateStrings: true,\n        ...config,\n    }))\n}\n\n"],"names":["DuplicateKey","MariaDB"],"mappings":"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"}