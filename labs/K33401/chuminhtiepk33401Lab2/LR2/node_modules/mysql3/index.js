'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var MariaDB = require('mariadb');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var MariaDB__default = /*#__PURE__*/_interopDefaultLegacy(MariaDB);

const CHARS_REGEX = /[\x00\b\n\r\t\x1A'\\]/gu;
const CHARS_ESCAPE_MAP = {
    '\0': '\\0',
    '\b': '\\b',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t',
    '\x1a': '\\Z',
    '\'': "''",
    '\\': '\\\\'
};
const ID_GLOBAL_REGEXP = /`/g;
const QUAL_GLOBAL_REGEXP = /\./g;
class SqlFrag {
    sql;
    constructor(sql) {
        this.sql = sql;
    }
    toString() {
        throw new Error("SqlFrag cannot be cast to string");
    }
    toSqlString() {
        return this.sql;
    }
}
function isFrag(x) {
    return x instanceof SqlFrag;
}
function frag(sql) {
    return new SqlFrag(sql);
}
function escapeValue(value) {
    if (isFrag(value))
        return value;
    return frag(_escapeValue(value));
}
function sql(strings, ...values) {
    let out = [];
    let i = 0;
    for (; i < values.length; ++i) {
        out.push(strings[i], escapeValue(values[i]).toSqlString());
    }
    out.push(strings[i]);
    return frag(out.join(''));
}
function _escapeValue(value) {
    if (isFrag(value)) {
        return value.toSqlString();
    }
    if (Array.isArray(value)) {
        if (!value.length)
            return '/*emptyArr*/NULL';
        return value.map(v => _escapeValue(v)).join(',');
    }
    if (Buffer.isBuffer(value)) {
        return `x'${value.toString('hex')}'`;
    }
    if (typeof value === 'number' || typeof value === 'bigint') {
        return String(value);
    }
    if (typeof value === 'string') {
        return _escapeString(value);
    }
    if (value === true) {
        return '1';
    }
    if (value === false) {
        return '0';
    }
    if (value === null) {
        return 'NULL';
    }
    if (value instanceof Date) {
        return `TIMESTAMP'${value.toISOString().replace('T', ' ').replace(/(?:\.000)?Z$/, '')}'`;
    }
    throw new Error(`Unsupported value type: ${value}`);
}
function _escapeString(value) {
    return "'" + String(value).replace(CHARS_REGEX, m => CHARS_ESCAPE_MAP[m]) + "'";
}
function escapeIdStrictFrag(id) {
    if (isFrag(id))
        return id;
    if (Array.isArray(id))
        return frag(id.map(_escapeIdStrict).join('.'));
    return frag(_escapeIdStrict(id));
}
function _escapeIdLoose(id) {
    if (isFrag(id))
        return id.toSqlString();
    if (Array.isArray(id))
        return id.map(_escapeIdStrict).join('.');
    return '`' + String(id).replace(ID_GLOBAL_REGEXP, '``').replace(QUAL_GLOBAL_REGEXP, '`.`') + '`';
}
function _escapeIdStrict(id) {
    if (isFrag(id))
        return id.toSqlString();
    if (Array.isArray(id))
        return id.map(_escapeIdStrict).join('.');
    return '`' + String(id).replace(ID_GLOBAL_REGEXP, '``') + '`';
}
const EMPTY_OBJECT = Object.freeze({ __proto__: null });
exports.DuplicateKey = void 0;
(function (DuplicateKey) {
    DuplicateKey["IGNORE"] = "ignore";
    DuplicateKey["UPDATE"] = "update";
})(exports.DuplicateKey || (exports.DuplicateKey = {}));
function getFields(o) {
    return Object.keys(o).filter(k => o[k] !== undefined);
}
sql `1`;
sql `0`;
(function (sql) {
    function set(fields) {
        if (Array.isArray(fields)) {
            const filteredFields = fields.filter(p => p[1] !== undefined);
            if (!filteredFields.length)
                throw new Error("No fields defined");
            return frag(filteredFields
                .map(f => `${_escapeIdStrict(f[0])}=${_escapeValue(f[1])}`)
                .join(', '));
        }
        const filteredFields = getFields(fields);
        if (!filteredFields.length)
            throw new Error("No fields defined");
        return frag(filteredFields
            .map(fieldName => `${_escapeIdLoose(fieldName)}=${_escapeValue(fields[fieldName])}`)
            .join(', '));
    }
    sql.set = set;
    function insert(table, data, options = EMPTY_OBJECT) {
        let q = sql `INSERT ${frag(options.ignore ? 'IGNORE ' : '')}INTO ${escapeIdStrictFrag(table)} SET ${sql.set(data)}`;
        if (options.onDuplicateKey === exports.DuplicateKey.IGNORE) {
            let firstCol;
            if (Array.isArray(data)) {
                firstCol = data[0][0];
            }
            else {
                firstCol = Object.keys(data)[0];
            }
            const escCol = frag(_escapeIdLoose(firstCol));
            q = sql `${q} ON DUPLICATE KEY UPDATE ${escCol}=${escCol}`;
        }
        else if (options.onDuplicateKey === exports.DuplicateKey.UPDATE) {
            let cols;
            if (Array.isArray(data)) {
                cols = data.map(f => f[0]);
            }
            else {
                cols = getFields(data);
            }
            q = sql `${q} ON DUPLICATE KEY UPDATE ${cols.map(col => {
                const escCol = frag(_escapeIdLoose(col));
                return sql `${escCol}=VALUES(${escCol})`;
            })}`;
        }
        return q;
    }
    sql.insert = insert;
    function alias(fields) {
        if (Array.isArray(fields)) {
            return frag(fields.map(f => `${_escapeIdStrict(f[0])} AS ${_escapeIdStrict(f[1])}`).join(', '));
        }
        return frag(getFields(fields).map(alias => `${_escapeIdStrict(fields[alias])} AS ${_escapeIdStrict(alias)}`).join(', '));
    }
    sql.alias = alias;
    function raw(sqlString) {
        if (isFrag(sqlString))
            return sqlString;
        return frag(sqlString);
    }
    sql.raw = raw;
    function point(x, y) {
        return sql `PointFromText(${`POINT(${x} ${y})`})`;
    }
    sql.point = point;
    function id(id) {
        return escapeIdStrictFrag(id);
    }
    sql.id = id;
    function db(id) {
        return escapeIdStrictFrag(id);
    }
    sql.db = db;
    function tbl(id) {
        return escapeIdStrictFrag(id);
    }
    sql.tbl = tbl;
    function col(id) {
        return escapeIdStrictFrag(id);
    }
    sql.col = col;
    function cols(...columns) {
        return frag(columns.map(_escapeIdStrict).join(', '));
    }
    sql.cols = cols;
    function columns(columns) {
        return frag(columns.map(_escapeIdStrict).join(', '));
    }
    sql.columns = columns;
    function values(values) {
        return frag(values.map(row => `(${row.map(_escapeValue).join(',')})`).join(',\n'));
    }
    sql.values = values;
})(sql || (sql = {}));

class ConnectionPool {
    pool;
    constructor(pool) {
        this.pool = pool;
    }
    async getConnection() {
        return new PoolConnection(await this.pool.getConnection());
    }
    _fwd(method) {
        return (async (...args) => {
            const conn = await this.getConnection();
            try {
                return await conn[method](...args);
            }
            finally {
                conn.release();
            }
        });
    }
    query = this._fwd('query');
    exec = this._fwd('exec');
    row = this._fwd('row');
    col = this._fwd('col');
    value = this._fwd('value');
    exists = this._fwd('exists');
    count = this._fwd('count');
    async *stream(query) {
        const conn = await this.getConnection();
        try {
            yield* conn.stream(query);
        }
        finally {
            conn.release();
        }
        return;
    }
    close() {
        return this.pool.end();
    }
    async transaction(callback) {
        if (Array.isArray(callback)) {
            return this.transaction(async (conn) => {
                const results = await Promise.allSettled(callback.map(sql => conn.query(sql)));
                if (results.some(r => r.status === 'rejected')) {
                    const errors = zip(callback, results).map((x, i) => ({
                        index: i,
                        query: x[0],
                        result: x[1],
                    })).filter(r => r.result.status === 'rejected');
                    throw Error(`${errors.length} quer${errors.length === 1 ? 'y' : 'ies'} failed:${errors.map(err => `\n[${err.index}] ${err.query.toSqlString()} :: ${err.result.reason}`).join('')}`);
                }
                return results.map(r => r.value);
            });
        }
        const conn = await this.getConnection();
        try {
            await conn.beginTransaction();
            let result;
            try {
                result = await callback(conn);
            }
            catch (err) {
                await conn.rollback();
                throw err;
            }
            await conn.commit();
            return result;
        }
        finally {
            await conn.release();
        }
    }
    get activeConnections() {
        return this.pool.activeConnections();
    }
    get totalConnections() {
        return this.pool.totalConnections();
    }
    get idleConnections() {
        return this.pool.idleConnections();
    }
    get taskQueueSize() {
        return this.pool.taskQueueSize();
    }
}
function zip(a, b) {
    if (a.length !== b.length)
        throw new Error("Cannot zip arrays; lengths differ");
    return a.map((x, i) => [x, b[i]]);
}
function makeOptions(query) {
    if (query instanceof SqlFrag) {
        return { sql: query };
    }
    else if (typeof query === 'object') {
        return query;
    }
    throw new Error(`Expected sql\`template string\` or {options}, got ${typeof query}`);
}
class PoolConnection {
    conn;
    constructor(conn) {
        this.conn = conn;
    }
    query(query) {
        const opts = makeOptions(query);
        return this.conn.query({
            ...opts,
            sql: opts.sql.toSqlString(),
        });
    }
    exec = this.query.bind(this);
    async row(query) {
        const opts = makeOptions(query);
        const rows = await this.query({
            ...opts,
            sql: sql `select * from (${opts.sql}) _query limit 1`
        });
        return rows.length ? rows[0] : null;
    }
    async col(query) {
        const rows = await this.query({
            sql: query,
            rowsAsArray: true,
        });
        if (!rows.length)
            return [];
        if (rows[0].length !== 1)
            throw new Error(`Expected exactly 1 field in query, got ${rows[0].length}`);
        return rows.map(r => r[0]);
    }
    async value(query) {
        const row = await this.row({
            sql: query,
            rowsAsArray: true,
        });
        if (!row)
            return null;
        if (row.length !== 1)
            throw new Error(`Expected exactly 1 field in query, got ${row.length}`);
        return row[0];
    }
    async exists(query) {
        return Boolean(await this.value(sql `select exists(${query})`));
    }
    async count(query) {
        return Number(await this.value(sql `select count(*) from (${query}) _query`));
    }
    async *stream(query) {
        let results = [];
        let resolve;
        let promise = new Promise(r => resolve = r);
        let done = false;
        this.conn.queryStream(query.toSqlString())
            .on('error', err => {
            throw err;
        })
            .on('data', row => {
            results.push(row);
            resolve();
        })
            .on('end', () => {
            done = true;
            resolve();
        });
        for (;;) {
            await promise;
            yield* results;
            if (done)
                break;
            promise = new Promise(r => resolve = r);
            results = [];
        }
        return;
    }
    release() { return this.conn.release(); }
    beginTransaction() { return this.conn.beginTransaction(); }
    commit() { return this.conn.commit(); }
    rollback() { return this.conn.rollback(); }
    ping() { return this.conn.ping(); }
    changeUser() { return this.conn.changeUser(); }
    close() { return this.conn.end(); }
    destroy() { return this.conn.destroy(); }
    get serverVersion() {
        return this.conn.serverVersion();
    }
    get isValid() {
        return this.conn.isValid();
    }
}
async function createPool(config) {
    return new ConnectionPool(await MariaDB__default['default'].createPool({
        supportBigInt: true,
        dateStrings: true,
        ...config,
    }));
}

exports.createPool = createPool;
exports.escapeIdLoose = _escapeIdLoose;
exports.escapeIdStrict = _escapeIdStrict;
exports.escapeValue = _escapeValue;
exports.sql = sql;
//# sourceMappingURL=index.js.map
